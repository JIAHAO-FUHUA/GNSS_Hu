// Generated by gencpp from file gnss_comm/GnssEphemeris.msg
// DO NOT EDIT!


#ifndef GNSS_COMM_MESSAGE_GNSSEPHEMERIS_H
#define GNSS_COMM_MESSAGE_GNSSEPHEMERIS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace gnss_comm
{
template <class ContainerAllocator>
struct GnssEphemeris_
{
  typedef GnssEphemeris_<ContainerAllocator> Type;

  GnssEphemeris_()
    : prn()
    , week(0)
    , sva(0)
    , code(0)
    , iode(0)
    , iodc(0)
    , svh(0)
    , toc(0.0)
    , idot(0.0)
    , crs(0.0)
    , deln(0.0)
    , M0(0.0)
    , cuc(0.0)
    , e(0.0)
    , cus(0.0)
    , A(0.0)
    , toes(0.0)
    , cic(0.0)
    , OMG0(0.0)
    , cis(0.0)
    , i0(0.0)
    , crc(0.0)
    , omg(0.0)
    , OMGd(0.0)
    , tgd()
    , f2(0.0)
    , f1(0.0)
    , f0(0.0)  {
    }
  GnssEphemeris_(const ContainerAllocator& _alloc)
    : prn(_alloc)
    , week(0)
    , sva(0)
    , code(0)
    , iode(0)
    , iodc(0)
    , svh(0)
    , toc(0.0)
    , idot(0.0)
    , crs(0.0)
    , deln(0.0)
    , M0(0.0)
    , cuc(0.0)
    , e(0.0)
    , cus(0.0)
    , A(0.0)
    , toes(0.0)
    , cic(0.0)
    , OMG0(0.0)
    , cis(0.0)
    , i0(0.0)
    , crc(0.0)
    , omg(0.0)
    , OMGd(0.0)
    , tgd(_alloc)
    , f2(0.0)
    , f1(0.0)
    , f0(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _prn_type;
  _prn_type prn;

   typedef uint16_t _week_type;
  _week_type week;

   typedef uint8_t _sva_type;
  _sva_type sva;

   typedef uint16_t _code_type;
  _code_type code;

   typedef uint8_t _iode_type;
  _iode_type iode;

   typedef uint16_t _iodc_type;
  _iodc_type iodc;

   typedef uint8_t _svh_type;
  _svh_type svh;

   typedef double _toc_type;
  _toc_type toc;

   typedef double _idot_type;
  _idot_type idot;

   typedef double _crs_type;
  _crs_type crs;

   typedef double _deln_type;
  _deln_type deln;

   typedef double _M0_type;
  _M0_type M0;

   typedef double _cuc_type;
  _cuc_type cuc;

   typedef double _e_type;
  _e_type e;

   typedef double _cus_type;
  _cus_type cus;

   typedef double _A_type;
  _A_type A;

   typedef double _toes_type;
  _toes_type toes;

   typedef double _cic_type;
  _cic_type cic;

   typedef double _OMG0_type;
  _OMG0_type OMG0;

   typedef double _cis_type;
  _cis_type cis;

   typedef double _i0_type;
  _i0_type i0;

   typedef double _crc_type;
  _crc_type crc;

   typedef double _omg_type;
  _omg_type omg;

   typedef double _OMGd_type;
  _OMGd_type OMGd;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _tgd_type;
  _tgd_type tgd;

   typedef double _f2_type;
  _f2_type f2;

   typedef double _f1_type;
  _f1_type f1;

   typedef double _f0_type;
  _f0_type f0;





  typedef boost::shared_ptr< ::gnss_comm::GnssEphemeris_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gnss_comm::GnssEphemeris_<ContainerAllocator> const> ConstPtr;

}; // struct GnssEphemeris_

typedef ::gnss_comm::GnssEphemeris_<std::allocator<void> > GnssEphemeris;

typedef boost::shared_ptr< ::gnss_comm::GnssEphemeris > GnssEphemerisPtr;
typedef boost::shared_ptr< ::gnss_comm::GnssEphemeris const> GnssEphemerisConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gnss_comm::GnssEphemeris_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::gnss_comm::GnssEphemeris_<ContainerAllocator1> & lhs, const ::gnss_comm::GnssEphemeris_<ContainerAllocator2> & rhs)
{
  return lhs.prn == rhs.prn &&
    lhs.week == rhs.week &&
    lhs.sva == rhs.sva &&
    lhs.code == rhs.code &&
    lhs.iode == rhs.iode &&
    lhs.iodc == rhs.iodc &&
    lhs.svh == rhs.svh &&
    lhs.toc == rhs.toc &&
    lhs.idot == rhs.idot &&
    lhs.crs == rhs.crs &&
    lhs.deln == rhs.deln &&
    lhs.M0 == rhs.M0 &&
    lhs.cuc == rhs.cuc &&
    lhs.e == rhs.e &&
    lhs.cus == rhs.cus &&
    lhs.A == rhs.A &&
    lhs.toes == rhs.toes &&
    lhs.cic == rhs.cic &&
    lhs.OMG0 == rhs.OMG0 &&
    lhs.cis == rhs.cis &&
    lhs.i0 == rhs.i0 &&
    lhs.crc == rhs.crc &&
    lhs.omg == rhs.omg &&
    lhs.OMGd == rhs.OMGd &&
    lhs.tgd == rhs.tgd &&
    lhs.f2 == rhs.f2 &&
    lhs.f1 == rhs.f1 &&
    lhs.f0 == rhs.f0;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::gnss_comm::GnssEphemeris_<ContainerAllocator1> & lhs, const ::gnss_comm::GnssEphemeris_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace gnss_comm

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gnss_comm::GnssEphemeris_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gnss_comm::GnssEphemeris_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gnss_comm::GnssEphemeris_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f182a49b5f433f32cb565ad1e7c4c34a";
  }

  static const char* value(const ::gnss_comm::GnssEphemeris_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf182a49b5f433f32ULL;
  static const uint64_t static_value2 = 0xcb565ad1e7c4c34aULL;
};

template<class ContainerAllocator>
struct DataType< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gnss_comm/GnssEphemeris";
  }

  static const char* value(const ::gnss_comm::GnssEphemeris_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string prn        # Satellite PRN number\n"
"uint16 week       # GPS week\n"
"uint8 sva         # SV accuracy (URA index)\n"
"uint16 code       # GPS: code on L2, GAL/BDS: data source\n"
"uint8 iode        # Issue of data, ephemeris\n"
"uint16 iodc       # Issue of data, clock\n"
"uint8 svh         # SV health\n"
"float64 toc       # Time of clock\n"
"float64 idot      # SV orbit parameter\n"
"float64 crs       # SV orbit parameter\n"
"float64 deln      # SV orbit parameter\n"
"float64 M0        # SV orbit parameter\n"
"float64 cuc       # SV orbit parameter\n"
"float64 e         # SV orbit parameter\n"
"float64 cus       # SV orbit parameter\n"
"float64 A         # SV orbit parameter\n"
"float64 toes      # SV orbit parameter\n"
"float64 cic       # SV orbit parameter\n"
"float64 OMG0      # SV orbit parameter\n"
"float64 cis       # SV orbit parameter\n"
"float64 i0        # SV orbit parameter\n"
"float64 crc       # SV orbit parameter\n"
"float64 omg       # SV orbit parameter\n"
"float64 OMGd      # SV orbit parameter\n"
"float64[] tgd     # Group delay parameters\n"
"float64 f2        # SV clock parameter\n"
"float64 f1        # SV clock parameter\n"
"float64 f0        # SV clock parameter\n"
;
  }

  static const char* value(const ::gnss_comm::GnssEphemeris_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.prn);
      stream.next(m.week);
      stream.next(m.sva);
      stream.next(m.code);
      stream.next(m.iode);
      stream.next(m.iodc);
      stream.next(m.svh);
      stream.next(m.toc);
      stream.next(m.idot);
      stream.next(m.crs);
      stream.next(m.deln);
      stream.next(m.M0);
      stream.next(m.cuc);
      stream.next(m.e);
      stream.next(m.cus);
      stream.next(m.A);
      stream.next(m.toes);
      stream.next(m.cic);
      stream.next(m.OMG0);
      stream.next(m.cis);
      stream.next(m.i0);
      stream.next(m.crc);
      stream.next(m.omg);
      stream.next(m.OMGd);
      stream.next(m.tgd);
      stream.next(m.f2);
      stream.next(m.f1);
      stream.next(m.f0);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GnssEphemeris_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gnss_comm::GnssEphemeris_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gnss_comm::GnssEphemeris_<ContainerAllocator>& v)
  {
    s << indent << "prn: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.prn);
    s << indent << "week: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.week);
    s << indent << "sva: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sva);
    s << indent << "code: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.code);
    s << indent << "iode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.iode);
    s << indent << "iodc: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.iodc);
    s << indent << "svh: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.svh);
    s << indent << "toc: ";
    Printer<double>::stream(s, indent + "  ", v.toc);
    s << indent << "idot: ";
    Printer<double>::stream(s, indent + "  ", v.idot);
    s << indent << "crs: ";
    Printer<double>::stream(s, indent + "  ", v.crs);
    s << indent << "deln: ";
    Printer<double>::stream(s, indent + "  ", v.deln);
    s << indent << "M0: ";
    Printer<double>::stream(s, indent + "  ", v.M0);
    s << indent << "cuc: ";
    Printer<double>::stream(s, indent + "  ", v.cuc);
    s << indent << "e: ";
    Printer<double>::stream(s, indent + "  ", v.e);
    s << indent << "cus: ";
    Printer<double>::stream(s, indent + "  ", v.cus);
    s << indent << "A: ";
    Printer<double>::stream(s, indent + "  ", v.A);
    s << indent << "toes: ";
    Printer<double>::stream(s, indent + "  ", v.toes);
    s << indent << "cic: ";
    Printer<double>::stream(s, indent + "  ", v.cic);
    s << indent << "OMG0: ";
    Printer<double>::stream(s, indent + "  ", v.OMG0);
    s << indent << "cis: ";
    Printer<double>::stream(s, indent + "  ", v.cis);
    s << indent << "i0: ";
    Printer<double>::stream(s, indent + "  ", v.i0);
    s << indent << "crc: ";
    Printer<double>::stream(s, indent + "  ", v.crc);
    s << indent << "omg: ";
    Printer<double>::stream(s, indent + "  ", v.omg);
    s << indent << "OMGd: ";
    Printer<double>::stream(s, indent + "  ", v.OMGd);
    s << indent << "tgd[]" << std::endl;
    for (size_t i = 0; i < v.tgd.size(); ++i)
    {
      s << indent << "  tgd[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tgd[i]);
    }
    s << indent << "f2: ";
    Printer<double>::stream(s, indent + "  ", v.f2);
    s << indent << "f1: ";
    Printer<double>::stream(s, indent + "  ", v.f1);
    s << indent << "f0: ";
    Printer<double>::stream(s, indent + "  ", v.f0);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GNSS_COMM_MESSAGE_GNSSEPHEMERIS_H
